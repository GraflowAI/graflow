"""
Global Workflow Context
=======================

This example demonstrates the global workflow context - a fallback context that
is automatically created when tasks are defined outside of an explicit workflow
context manager.

Prerequisites:
--------------
None

Concepts Covered:
-----------------
1. Global workflow context behavior
2. Automatic context creation
3. Context isolation between explicit and global contexts
4. When to use global vs explicit contexts
5. Accessing the current workflow context

Expected Output:
----------------
=== Global Workflow Context ===

Scenario 1: Global Context Fallback

Creating tasks without explicit context...
✅ Global tasks created

Global workflow context:
Name: <auto-generated-uuid>
Tasks: 2
Dependencies: 1

Executing global tasks:
Global task A
Global task B

Scenario 2: Isolated Explicit Context

Creating tasks in explicit context...

Isolated context workflow:
Name: isolated_context
Tasks: 2
Dependencies: 1

Executing isolated context:
Context task A
Context task B

=== Summary ===
✅ Global context automatically created
✅ Explicit contexts remain isolated
✅ Both contexts work independently
✅ Use explicit contexts for better control
"""

from graflow.core.decorators import task
from graflow.core.workflow import current_workflow_context, workflow


def scenario_1_global_context():
    """Scenario 1: Global context fallback behavior."""
    print("=== Scenario 1: Global Context Fallback ===\n")
    print("Creating tasks without explicit context...\n")

    # These tasks will use the global fallback context
    # When no explicit context exists, a global context is created
    @task
    def global_task_a():
        """First task in global context."""
        print("Global task A")

    @task
    def global_task_b():
        """Second task in global context."""
        print("Global task B")

    # Build dependencies in global context
    _ = global_task_a >> global_task_b
    print("✅ Global tasks created\n")

    # Access the global context
    global_context = current_workflow_context()
    print("Global workflow context:")
    global_context.show_info()

    # Execute global tasks
    print("\nExecuting global tasks:")
    global_context.execute()


def scenario_2_isolated_context():
    """Scenario 2: Isolated explicit context."""
    print("\n=== Scenario 2: Isolated Explicit Context ===\n")
    print("Creating tasks in explicit context...\n")

    # Explicit context - isolated from global context
    with workflow("isolated_context") as isolated:

        @task
        def context_task_a():
            """First task in explicit context."""
            print("Context task A")

        @task
        def context_task_b():
            """Second task in explicit context."""
            print("Context task B")

        # These dependencies are in the isolated context only
        _ = context_task_a >> context_task_b

        print("Isolated context workflow:")
        isolated.show_info()

        print("\nExecuting isolated context:")
        isolated.execute()


def scenario_3_accessing_current_context():
    """Scenario 3: Accessing the current context from tasks."""
    print("\n=== Scenario 3: Accessing Current Context ===\n")

    with workflow("context_access") as ctx:

        @task(inject_context=True)
        def task_with_context(context):
            """Task that accesses its workflow context."""
            # Get the current workflow context
            current_ctx = current_workflow_context()
            print(f"Task executing in workflow: {current_ctx.name}")
            print(f"Workflow has {len(current_ctx.graph.nodes)} tasks")

        @task
        def regular_task():
            """Regular task without context injection."""
            # Can still access global context
            ctx = current_workflow_context()
            print(f"Regular task in workflow: {ctx.name}")

        _ = task_with_context >> regular_task

        print("Context access workflow:")
        ctx.show_info()

        print("Executing context-aware tasks:")
        ctx.execute()


def scenario_4_mixed_contexts():
    """Scenario 4: Mixing global and explicit contexts."""
    print("\n=== Scenario 4: Mixed Contexts ===\n")

    # Global task
    @task
    def global_task():
        """Task in global context."""
        ctx = current_workflow_context()
        print(f"Global task in: {ctx.name}")

    # Explicit context 1
    with workflow("explicit_1") as ctx1:

        @task
        def ctx1_task():
            """Task in explicit context 1."""
            ctx = current_workflow_context()
            print(f"Explicit 1 task in: {ctx.name}")

        print("Executing explicit context 1:")
        ctx1.execute("ctx1_task")

    # Explicit context 2
    with workflow("explicit_2") as ctx2:

        @task
        def ctx2_task():
            """Task in explicit context 2."""
            ctx = current_workflow_context()
            print(f"Explicit 2 task in: {ctx.name}")

        print("\nExecuting explicit context 2:")
        ctx2.execute("ctx2_task")

    # Execute global task
    print("\nExecuting global task:")
    global_ctx = current_workflow_context()
    global_ctx.execute("global_task")


def scenario_5_nested_context_access():
    """Scenario 5: Context access in nested workflows."""
    print("\n=== Scenario 5: Nested Context Access ===\n")

    with workflow("outer") as outer:

        @task
        def outer_task():
            """Task in outer context."""
            print("Outer task: Starting")

            # Create nested context
            with workflow("inner") as inner:

                @task
                def inner_task():
                    """Task in nested context."""
                    ctx = current_workflow_context()
                    print(f"  Inner task in: {ctx.name}")

                print("  Executing inner workflow...")
                inner.execute("inner_task")

            print("Outer task: Completed inner workflow")

        print("Executing nested workflow:")
        outer.execute("outer_task")


def main():
    """Run all global context scenarios."""
    print("=== Global Workflow Context ===\n")

    # Scenario 1: Global context fallback
    scenario_1_global_context()

    # Scenario 2: Isolated explicit context
    scenario_2_isolated_context()

    # Scenario 3: Accessing current context
    scenario_3_accessing_current_context()

    # Scenario 4: Mixed contexts
    scenario_4_mixed_contexts()

    # Scenario 5: Nested context access
    scenario_5_nested_context_access()

    print("\n=== Summary ===")
    print("✅ Global context automatically created")
    print("✅ Explicit contexts remain isolated")
    print("✅ Both contexts work independently")
    print("✅ Use explicit contexts for better control")


if __name__ == "__main__":
    main()


# ============================================================================
# Key Takeaways:
# ============================================================================
#
# 1. **Global Context Behavior**
#    - Created automatically when no explicit context exists
#    - Provides fallback for tasks defined outside workflow() blocks
#    - Has auto-generated UUID as name
#    - Accessed via current_workflow_context()
#
# 2. **When Global Context is Used**
#    - Tasks defined at module level
#    - Quick prototyping and testing
#    - Simple scripts without workflow structure
#    - Backward compatibility with older code
#
# 3. **Explicit vs Global Context**
#    Explicit (Recommended):
#    ✅ Better control over workflow structure
#    ✅ Clear workflow boundaries
#    ✅ Explicit naming
#    ✅ Easier to test and maintain
#
#    Global:
#    ✅ Quick prototyping
#    ✅ Simple scripts
#    ⚠️  Less explicit structure
#    ⚠️  Auto-generated name
#
# 4. **Context Isolation**
#    - Each explicit context is isolated
#    - Global context is separate from explicit contexts
#    - Tasks can only see their own context
#    - No cross-context dependencies
#
# 5. **Best Practices**
#    ✅ Use explicit contexts for production code
#    ✅ Use global context for quick scripts
#    ✅ Don't mix global and explicit contexts
#    ✅ Name your contexts meaningfully
#    ✅ Keep context scope clear
#
# ============================================================================
# Common Patterns:
# ============================================================================
#
# **Pattern 1: Quick Script (Global)**
# from graflow.core.decorators import task
# from graflow.core.workflow import current_workflow_context
#
# @task
# def task1():
#     print("Task 1")
#
# @task
# def task2():
#     print("Task 2")
#
# task1 >> task2
# current_workflow_context().execute("task1")
#
# **Pattern 2: Structured Workflow (Explicit)**
# from graflow.core.workflow import workflow
#
# with workflow("my_pipeline") as ctx:
#     @task
#     def task1():
#         print("Task 1")
#
#     @task
#     def task2():
#         print("Task 2")
#
#     task1 >> task2
#     ctx.execute("task1")
#
# **Pattern 3: Multiple Workflows (Explicit)**
# with workflow("pipeline_1") as ctx1:
#     # Define tasks for pipeline 1
#     pass
#
# with workflow("pipeline_2") as ctx2:
#     # Define tasks for pipeline 2
#     pass
#
# ctx1.execute()
# ctx2.execute()
#
# ============================================================================
# Advanced Usage:
# ============================================================================
#
# **Accessing Context in Tasks**:
# @task(inject_context=True)
# def my_task(context):
#     workflow_ctx = current_workflow_context()
#     print(f"Running in: {workflow_ctx.name}")
#     # Access other workflow properties
#     print(f"Tasks: {len(workflow_ctx.graph.nodes)}")
#
# **Dynamic Context Creation**:
# def get_or_create_context(name: str):
#     try:
#         # Try to use existing context
#         return current_workflow_context()
#     except:
#         # Create new context
#         return workflow(name).__enter__()
#
# **Context Switching** (Not recommended):
# # This is advanced and can be confusing
# ctx1 = workflow("ctx1").__enter__()
# # ... define tasks ...
# ctx1.__exit__(None, None, None)
#
# ctx2 = workflow("ctx2").__enter__()
# # ... define tasks ...
# ctx2.__exit__(None, None, None)
#
# ============================================================================
# Troubleshooting:
# ============================================================================
#
# **Problem**: Tasks defined in wrong context
# **Solution**: Always use `with workflow(...)` to be explicit
#
# **Problem**: Can't access task from different context
# **Solution**: Tasks are context-scoped, define in same context
#
# **Problem**: Auto-generated context names in logs
# **Solution**: Use explicit contexts with meaningful names
#
# **Problem**: Context not found
# **Solution**: Ensure context is created before accessing
#
# ============================================================================
# Testing Tips:
# ============================================================================
#
# **Test Isolation**:
# def test_my_workflow():
#     with workflow("test_workflow") as ctx:
#         # Define and test tasks
#         # Context is isolated from other tests
#         pass
#
# **Mock Context**:
# from unittest.mock import Mock
# mock_ctx = Mock(spec=WorkflowContext)
# mock_ctx.name = "mock"
# mock_ctx.graph = Mock()
#
# **Context Cleanup**:
# # Contexts are automatically cleaned up when exiting the with block
# with workflow("temp") as ctx:
#     # Use context
#     pass
# # Context no longer active
#
# ============================================================================
